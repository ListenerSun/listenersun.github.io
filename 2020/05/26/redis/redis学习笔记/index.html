<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="日日求精进 但求无愧" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Redis这一篇就差不多了（待更新） |  倾听者
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="倾听者" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-redis/redis学习笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Redis这一篇就差不多了（待更新）
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-05-26T15:55:34.000Z" itemprop="datePublished">2020-05-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">21 分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Redis使用也挺久了，也没用到过高级用法，就是简单的做个缓存。以前也没系统的学过。前几天看了个Redis视频课程，就做了下笔记，大部分都是基础知识，没有涉及到高阶，但是也算是全面的梳理了一遍。<strong>纯手打! 实属不易! 点个赞吧！</strong></p>
<a id="more"></a>

<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><h4 id="常用命令-点击参考"><a href="#常用命令-点击参考" class="headerlink" title="常用命令(点击参考)"></a>常用命令(<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">点击参考</a>)</h4><ol>
<li><p>set命令设置 key value </p>
<ul>
<li><p><code>EX</code> <em>seconds</em> – 设置键key的过期时间，单位时秒</p>
</li>
<li><p><code>PX</code> <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒</p>
</li>
<li><p><code>NX</code> – 只有键key不存在的时候才会设置key的值</p>
</li>
<li><p><code>XX</code> – 只有键key存在的时候才会设置key的值</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; set key "Hello"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1：6379&gt; set key "hello" ex 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>get key</code>：获取某个key的value</p>
</li>
<li><p><code>APPEND key value</code>：追加一个值到<code>key</code>上，如果<code>key</code>不存在则创建一个<code>key</code></p>
</li>
<li><p><code>MSET key1 value1 key2 value2]</code>：设置多个 key value</p>
</li>
<li><p><code>MGET key1 key2</code>：获取多个值，如果key不存在，返回<code>nil</code></p>
</li>
<li><p><code>INCR key</code>(只操作整数)：执行原子加一操作，如果key不存在，则key从0开始加1.</p>
</li>
<li><p><code>INCRBY key increment</code>(只操作整数)`：执行<strong>原子</strong>增加一个值，如果key不存在，key被设置为0，如果数据类型错误返回错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; set num 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1：6379&gt; INCRBY num 2</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1：6379&gt; INCRBY num "sss"</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DECR key(只操作整数)</code>：整数<code>原子</code>减一，如果key不存在，则key从0开始减一，如果数据类型错误，返回错误。</p>
</li>
<li><p><code>DECRBY key decrement</code>(只操作整数)：<strong>原子性</strong>减指定的数，如果key不存在，则key被置为0，然后相减</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; set num 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1：6379&gt; DECRBY num 5</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>缓存</li>
</ol>
<h3 id="Hashes（哈希）"><a href="#Hashes（哈希）" class="headerlink" title="Hashes（哈希）"></a>Hashes（哈希）</h3><h4 id="常用命令-点击参考-1"><a href="#常用命令-点击参考-1" class="headerlink" title="常用命令(点击参考)"></a>常用命令(<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">点击参考</a>)</h4><ol>
<li><p><code>HSET key field value</code>：设置hash里面一个字段的值</p>
</li>
<li><p><code>HGET key field</code>：获取某个字段的值</p>
</li>
<li><p><code>HDEL key field</code>：删除<strong>1个或多个</strong>字段的值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; HSET sqt name 'listener'</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1：6379&gt; HGET sqt name</span><br><span class="line">"listener"</span><br><span class="line">127.0.0.1：6379&gt; HDEL sqt name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1：6379&gt; HGET sqt name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HKEYS key</code>：获取 key 所有字段的名字</p>
</li>
<li><p><code>HVALS key</code>：返回key所有字段的value值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hset sqt name listener age 20 address '西安'</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1：6379&gt; HKEYS sqt</span><br><span class="line">1) "name"</span><br><span class="line">2) "age"</span><br><span class="line">3) "address"</span><br><span class="line">127.0.0.1：6379&gt; HVALS sqt</span><br><span class="line">1) "listener"</span><br><span class="line">2) "20"</span><br><span class="line">3) "\xe8\xa5\xbf\xe5\xae\x89"</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HGETALL key</code>：返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>个人用户首页访问量</li>
</ol>
</li>
</ol>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Redis lists<strong>基于Linked Lists实现</strong>。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的</p>
<h4 id="常用命令-点击参考-2"><a href="#常用命令-点击参考-2" class="headerlink" title="常用命令(点击参考)"></a>常用命令(<a href="http://www.redis.cn/commands/brpoplpush.html" target="_blank" rel="noopener">点击参考</a>)</h4><ol>
<li><p><code>LSET key index value</code>：设置 index 位置的list元素的值为 value，当index超出范围返回一个error</p>
</li>
<li><p><code>LPUSH key value1 value2</code>：从队列左边向右边入队一个或多个元素</p>
</li>
<li><p><code>LPOP key</code>：移除并且返回 key 对应的 list 的第一个元素。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH sqt name age address</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LPOP sqt</span><br><span class="line">"address"</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LLEN key</code>：返回存储在 key 里的list的长度。如果 key 不存在，会被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>粉丝列表、关注列表(利用队列的性质)</li>
<li>实现消息队列</li>
</ol>
</li>
</ol>
<h3 id="Sets（集合）"><a href="#Sets（集合）" class="headerlink" title="Sets（集合）"></a><strong>Sets</strong>（集合）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><strong>不重复且无序</strong>的字符串元素的集合</p>
<h4 id="常用命令-点击参考-3"><a href="#常用命令-点击参考-3" class="headerlink" title="常用命令(点击参考)"></a>常用命令(<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">点击参考</a>)</h4><ol>
<li><p><code>sadd key value1 value2</code>：添加一个和多个元素</p>
</li>
<li><p><code>sinter key1 key2</code>：求交集</p>
</li>
<li><p><code>SCARD key</code>：集合存储的key的基数 (集合元素的数量)</p>
</li>
<li><p><code>SREM key member1 member2</code>：移除key集合指定的元素. 如果指定元素不存在则忽略，如果key集合不存在返回0.</p>
</li>
<li><p><code>SPOP key [count]</code>：从存储在<code>key</code>的集合中<strong>移除并返回</strong>一个或多个随机元素</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; SPOP set</span><br><span class="line">"5"</span><br><span class="line">127.0.0.1:6379&gt; SPOP set</span><br><span class="line">"6"</span><br><span class="line">127.0.0.1:6379&gt; SPOP set</span><br><span class="line">"3"</span><br><span class="line">127.0.0.1:6379&gt; SPOP set 2</span><br><span class="line">1) "4"</span><br><span class="line">2) "1"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SRANDMEMBER key [count]</code>：随机返回key集合中的一个元素，<strong>不删除</strong></p>
</li>
</ol>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>共同好友—-&gt;<code>sinter key1 key2</code></li>
<li>抽奖系统—–&gt;<code>SRANDMEMBER key [count]</code>或<code>SPOP key [count]</code></li>
</ul>
<h3 id="Sorted-Sets-有序集合"><a href="#Sorted-Sets-有序集合" class="headerlink" title="Sorted Sets(有序集合)"></a><strong>Sorted Sets(有序集合)</strong></h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>类似Sets。但是<strong>元素不重复且有序</strong>。但是每个字符串元素都关联到一个叫<em>score</em>浮动数值（floating number value）。里面的元素总是通过score进行着排序，所以不同的是，它是可以检索的一系列元素。</p>
<h4 id="基本命令-点击参考"><a href="#基本命令-点击参考" class="headerlink" title="基本命令(点击参考)"></a><strong>基本命令(<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">点击参考</a>)</strong></h4><ol>
<li><p><code>ZADD key score element</code>：添加一个或者多个元素， 如果元素(element)已存在，则更新并重新排序。如果key不存在，则创建新集合。复杂度 O(logN)    </p>
<ul>
<li><strong>XX</strong>: 仅仅更新存在的成员，不添加新成员。</li>
<li><strong>NX</strong>: 不更新存在的成员。只添加新成员。</li>
<li><strong>CH</strong>: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 <em>changed</em> 的意思)。更改的元素是<strong>新添加的成员</strong>，已经存在的成员<strong>更新分数</strong>。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，<code>ZADD</code>返回值只计算新添加成员的数量。</li>
<li><strong>INCR</strong>: 当<code>ZADD</code>指定这个选项时，成员的操作就等同<a href="http://www.redis.cn/commands/zincrby.html" target="_blank" rel="noopener">ZINCRBY</a>命令，对成员的分数进行递增操作。</li>
</ul>
</li>
<li><p><code>ZCARD key</code>：返回 key 集合元素的数量</p>
</li>
<li><p><code>ZREM key member [member ...]</code>：删除一个或多个元素，当key存在，但是其不是有序集合类型，就返回一个错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd user 100 listener 120 sqt</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrem user listener</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zcard user</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code>：有序集合中<strong>指定分数区间内</strong>的成员，分数由高到低排序</p>
<ul>
<li><p>完整语法示例：<code>ZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count</code></p>
</li>
<li><table>
<thead>
<tr>
<th>指令</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ZREVRANGEBYSCORE</td>
<td>是</td>
<td>指令</td>
</tr>
<tr>
<td>key</td>
<td>是</td>
<td>有序集合键名称</td>
</tr>
<tr>
<td>max</td>
<td>是</td>
<td>最大分数值,可使用”+inf”代替</td>
</tr>
<tr>
<td>min</td>
<td>是</td>
<td>最小分数值,可使用”-inf”代替</td>
</tr>
<tr>
<td>WITHSCORES</td>
<td>否</td>
<td>将成员分数一并返回</td>
</tr>
<tr>
<td>LIMIT</td>
<td>否</td>
<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>
</tr>
<tr>
<td>offset</td>
<td>否</td>
<td>返回结果起始位置</td>
</tr>
<tr>
<td>count</td>
<td>否</td>
<td>返回结果数量</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd exam_score 100 sqt 110 wby 70 cl 10 zhangsan 33 lisi 66 wangwu 77 chenliu 83 listener</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE exam_score 100 5 WITHSCORES</span><br><span class="line"> 1) "sqt"</span><br><span class="line"> 2) "100"</span><br><span class="line"> 3) "listener"</span><br><span class="line"> 4) "83"</span><br><span class="line"> 5) "chenliu"</span><br><span class="line"> 6) "77"</span><br><span class="line"> 7) "cl"</span><br><span class="line"> 8) "70"</span><br><span class="line"> 9) "wangwu"</span><br><span class="line">10) "66"</span><br><span class="line">11) "lisi"</span><br><span class="line">12) "33"</span><br><span class="line">13) "zhangsan"</span><br><span class="line">14) "10"</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code>：返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同</p>
<ul>
<li><p>完整语法：<code>ZREVRANGEBYLEX key max min [LIMIT offset count]</code></p>
</li>
<li><table>
<thead>
<tr>
<th>指令</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ZREVRANGEBYLEX</td>
<td>是</td>
<td>指令</td>
</tr>
<tr>
<td>key</td>
<td>是</td>
<td>有序集合键名称</td>
</tr>
<tr>
<td>max</td>
<td>是</td>
<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>
</tr>
<tr>
<td>min</td>
<td>是</td>
<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>
</tr>
<tr>
<td>LIMIT</td>
<td>否</td>
<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>
</tr>
<tr>
<td>offset</td>
<td>否</td>
<td>返回结果起始位置</td>
</tr>
<tr>
<td>count</td>
<td>否</td>
<td>返回结果数量</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>排行榜(根据点赞数、评论数)</li>
<li>热点数据</li>
</ol>
<h3 id="集合-VS-有序集合"><a href="#集合-VS-有序集合" class="headerlink" title="集合 VS 有序集合"></a><strong>集合 VS 有序集合</strong></h3><table>
<thead>
<tr>
<th align="center"><strong>集合</strong></th>
<th align="center"><strong>有序集合</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">无重复元素</td>
<td align="center">无重复元素</td>
</tr>
<tr>
<td align="center">无序</td>
<td align="center">有序</td>
</tr>
<tr>
<td align="center">element</td>
<td align="center">element + score</td>
</tr>
</tbody></table>
<h3 id="列表-VS-有序集合"><a href="#列表-VS-有序集合" class="headerlink" title="列表 VS 有序集合"></a><strong>列表 VS 有序集合</strong></h3><table>
<thead>
<tr>
<th align="center"><strong>列表</strong></th>
<th align="center"><strong>有序集合</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">元素可以重复</td>
<td align="center">元素不可以重复</td>
</tr>
<tr>
<td align="center">无序</td>
<td align="center">有序</td>
</tr>
<tr>
<td align="center">element</td>
<td align="center">element + score</td>
</tr>
</tbody></table>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a><strong>慢查询</strong></h3><p>客户端超时不一定是慢查询，但慢查询是客户端超时的一个因素</p>
<h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a><strong>生命周期：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送命令-&gt;命令排队-&gt;命令执行-&gt;返回结果</span><br></pre></td></tr></table></figure>

<p><strong>慢查询发生在 命令执行  阶段。</strong></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h4><ol>
<li>配置 <strong><code>slowlog-log-slower-than</code></strong> 指定执行时间超过多少微秒的命令会被记录到日志上<strong>(建议设置为1000)</strong></li>
<li>配置<strong><code>slowlog-max-len</code> **指定最多保存多少条慢查询记录</strong>.(默认10ms，建议1ms)**</li>
</ol>
<h3 id="pipeline（流水线）"><a href="#pipeline（流水线）" class="headerlink" title="pipeline（流水线）"></a><strong>pipeline（流水线）</strong></h3><p>一次网络时间，多条命令。节省网络传输时间</p>
<h3 id="redis持久化的取舍和选择"><a href="#redis持久化的取舍和选择" class="headerlink" title="redis持久化的取舍和选择"></a><strong>redis持久化的取舍和选择</strong></h3><h4 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a><strong>持久化方式</strong></h4><h6 id="快照（RDB）"><a href="#快照（RDB）" class="headerlink" title="快照（RDB）"></a><strong>快照（RDB）</strong></h6><p>​        例如：Redis RDB、Mysql Dump </p>
<h6 id="写日志（AOF）"><a href="#写日志（AOF）" class="headerlink" title="写日志（AOF）"></a><strong>写日志（AOF）</strong></h6><p>​        例如： Redis AOF、Mysql Binlog、Hbase Hlog</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RDB.png" alt="RDB.png"></p>
<h5 id="触发机制的三种方式"><a href="#触发机制的三种方式" class="headerlink" title="触发机制的三种方式"></a><strong>触发机制的三种方式</strong></h5><h6 id="save-命令-同步"><a href="#save-命令-同步" class="headerlink" title="save 命令(同步)"></a><strong>save 命令(同步)</strong></h6><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RDB-save.png" alt="RDB-save.png"></p>
<ol>
<li><strong>数据量大的时候会阻塞</strong></li>
<li><strong>如存在老的RDB文件，新替换老</strong></li>
<li><strong>复杂度O(N)</strong></li>
</ol>
<h6 id="bgsave（异步）"><a href="#bgsave（异步）" class="headerlink" title="bgsave（异步）"></a><strong>bgsave（异步）</strong></h6><p>​    <img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RDB-bgsave.png" alt="RDB-bgsave.png"></p>
<h6 id="save-和-bgsave-简单对比"><a href="#save-和-bgsave-简单对比" class="headerlink" title="save 和 bgsave 简单对比"></a><strong>save 和 bgsave 简单对比</strong></h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center"><strong>bgsave</strong></th>
<th align="center"><strong>save</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">IO类型</td>
<td align="center">异步</td>
<td align="center">同步</td>
</tr>
<tr>
<td align="center">阻塞</td>
<td align="center">是（阻塞发生在fork）</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">复杂度</td>
<td align="center">O(n)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">不阻塞客户端命令</td>
<td align="center">不会消耗额外内存</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">需要fork，消耗内存</td>
<td align="center">阻塞客户端命令</td>
</tr>
</tbody></table>
<h6 id="最佳配置"><a href="#最佳配置" class="headerlink" title="最佳配置"></a><strong>最佳配置</strong></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面 3 条 save 命令满足其中任何一个，都会执行 bgsave </span></span><br><span class="line">save 900 1 # 900秒内 改变超过 1条数据会执行 bgsave</span><br><span class="line">save 300 10  # 300秒内 改变超过 10条数据会执行 bgsave</span><br><span class="line">save 60 10000 # 60秒内 改变超过 10000条数据会执行 bgsave</span><br><span class="line">stop-writes-on-bgsave-error yes # bgsave 发生错误  停止写入</span><br><span class="line">rdbcompression yes # RDB文件是否采用压缩的格式</span><br><span class="line">rdbchecksum yes   # RDB文件是否检验</span><br><span class="line">dbfilename dump-$&#123;port&#125;.rdb # RDB文件名字</span><br></pre></td></tr></table></figure>

<h6 id="触发机制-不容忽略方式"><a href="#触发机制-不容忽略方式" class="headerlink" title="触发机制-不容忽略方式"></a><strong>触发机制-不容忽略方式</strong></h6><ol>
<li>全量复制 (比如主从复制的时候)</li>
<li>debug reload</li>
<li>shutdown （关闭的时候，有可能生成 RDB文件）</li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h6><ol>
<li>RDB是Redis内存到硬盘的快照，用于持久化</li>
<li>save命令通常会阻塞Redis</li>
<li>bgsave不会阻塞Redis，但是会fork新的进程</li>
<li>save自动配置满足任一就会被执行</li>
<li>有些触发机制不容忽视</li>
</ol>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h4><h5 id="AOF运行原理-创建-恢复"><a href="#AOF运行原理-创建-恢复" class="headerlink" title="AOF运行原理-创建/恢复"></a><strong>AOF运行原理-创建/恢复</strong></h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/D%EF%BC%9A%5Csqt%5Carticle%5Credis%5CAOF-%E5%88%9B%E5%BB%BA.png" alt="image-20200525183200381"></p>
<h5 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a><strong>三种策略</strong></h5><h6 id="always"><a href="#always" class="headerlink" title="always"></a><strong>always</strong></h6><p>每个命令都会进行持久化，数据不会丢失</p>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF-always.png" alt="AOF-always.png"></p>
<h6 id="everysec"><a href="#everysec" class="headerlink" title="everysec"></a><strong>everysec</strong></h6><p>Redis的默认配置，每一秒执行一次持久化，最多丢失一秒的数据。    <img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF-everysec.png" alt="AOF-everysec.png"></p>
<h6 id="no"><a href="#no" class="headerlink" title="no"></a><strong>no</strong></h6><p>由操作系统法国决定<img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF-no.png" alt="AOF-no.png"></p>
<h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h6><table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>always</strong></th>
<th align="center"><strong>everysec</strong></th>
<th align="center"><strong>no</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">不丢失数据</td>
<td align="center">每秒fsync，有可能丢1秒数据</td>
<td align="center">不用管</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">IO开销比较大，一般的<br>sata盘只有几百TPS</td>
<td align="center">丢失一秒数据</td>
<td align="center">不可控</td>
</tr>
</tbody></table>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a><strong>AOF重写</strong></h5><h6 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a><strong>AOF重写作用</strong></h6><ol>
<li>减少硬盘占用量</li>
<li>加速恢复速度</li>
</ol>
<h5 id="AOF实现的两种方式"><a href="#AOF实现的两种方式" class="headerlink" title="AOF实现的两种方式"></a><strong>AOF实现的两种方式</strong></h5><h6 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a><strong>bgrewriteaof</strong></h6><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF-bgwriteaof.png" alt="AOF-bgwriteaof.png"></p>
<h6 id="AOF重写配置"><a href="#AOF重写配置" class="headerlink" title="AOF重写配置"></a><strong>AOF重写配置</strong></h6><ol>
<li><p>配置</p>
<table>
<thead>
<tr>
<th align="center"><strong>配置名</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">auto-aof-rewrite-min-size</td>
<td align="center">AOF文件重写需要的尺寸</td>
</tr>
<tr>
<td align="center">auto-aof-rewrite-percentage</td>
<td align="center">AOF文件增长率</td>
</tr>
</tbody></table>
</li>
<li><p>统计</p>
<table>
<thead>
<tr>
<th align="center"><strong>统计名</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">aof_current_size</td>
<td align="center">AOF当前尺寸(单位：字节)</td>
</tr>
<tr>
<td align="center">aof_base_size</td>
<td align="center">AOF上次启动和重写的尺寸(单位：字节)</td>
</tr>
</tbody></table>
</li>
<li><p>AOF自动触发时机</p>
<ul>
<li>aof_current_size &gt; auto-aof-rewrite-min-size</li>
<li>(aof_current_size - aof_base_size)/aof_base_size &gt; auto-aof-rewrite-percentage</li>
</ul>
</li>
<li><p>AOF重写流程</p>
</li>
</ol>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF-%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="AOF-重写流程.png"></p>
<h4 id="AOF和RDB对比"><a href="#AOF和RDB对比" class="headerlink" title="AOF和RDB对比"></a>AOF和RDB对比</h4><table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>RDB</strong></th>
<th align="center"><strong>AOF</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">启动优先级</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">体积</td>
<td align="center">小</td>
<td align="center">大</td>
</tr>
<tr>
<td align="center">恢复速度</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据安全性</td>
<td align="center">丢数据</td>
<td align="center">根据策略决定</td>
</tr>
<tr>
<td align="center">轻重</td>
<td align="center">重</td>
<td align="center">轻</td>
</tr>
</tbody></table>
<h5 id="RBD最佳策略"><a href="#RBD最佳策略" class="headerlink" title="RBD最佳策略"></a><strong>RBD最佳策略</strong></h5><ol>
<li>建议关掉RDB</li>
<li>集中管理</li>
<li>主从，从开</li>
</ol>
<p><strong>AOF最佳策略</strong></p>
<ol>
<li>建议开启(缓存和存出)</li>
<li>AOF重写集中管理</li>
<li>使用everysec</li>
</ol>
<h5 id="最佳策略"><a href="#最佳策略" class="headerlink" title="最佳策略"></a><strong>最佳策略</strong></h5><ol>
<li>小分片</li>
<li>缓存或者存储</li>
<li>监控(硬盘、内存、负载、网络)</li>
<li>足够的内存</li>
</ol>
<h4 id="运维常见问题"><a href="#运维常见问题" class="headerlink" title="运维常见问题"></a><strong>运维常见问题</strong></h4><h5 id="fork操作"><a href="#fork操作" class="headerlink" title="fork操作"></a><strong>fork操作</strong></h5><ol>
<li>同步操作</li>
<li>于内存量息息相关：内存越大，耗时越长(与机器类型有关)</li>
<li>info：lastest_fork_usec（查看fork执行的时间信息）</li>
</ol>
<h6 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a><strong>改善fork</strong></h6><ol>
<li>优先使用 物理机或者高效支持fork操作的虚拟化技术</li>
<li>控制Redis实例最大可用内存：maxmemory</li>
<li>合理配置Linux内存分配策略： <code>vm.overcommit_ory=1</code></li>
<li>降低fork频率：例如放款AOF重写自动触发时机，不必要的全量赋值</li>
</ol>
<h5 id="子进程的开销和优化"><a href="#子进程的开销和优化" class="headerlink" title="子进程的开销和优化"></a><strong>子进程的开销和优化</strong></h5><h6 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h6><ul>
<li>开销： RDB和AOF文件生成，属于CPU密集型</li>
<li>优化：不做CPU绑定，不和CPU密集型的服务一块部署</li>
</ul>
<h6 id="内存"><a href="#内存" class="headerlink" title="内存"></a><strong>内存</strong></h6><ul>
<li>开销： fork内存开销， copy-on-write</li>
<li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled（<strong>禁用透明大页功能</strong>）</li>
</ul>
<h5 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a><strong>AOF追加阻塞</strong></h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF-%E8%BF%BD%E5%8A%A0%E9%98%BB%E5%A1%9E.png" alt="AOF-追加阻塞.png"></p>
<h6 id="AOF阻塞定位"><a href="#AOF阻塞定位" class="headerlink" title="AOF阻塞定位"></a><strong>AOF阻塞定位</strong></h6><ol>
<li><p>Redis日志</p>
<p>出现以下日志有可能出现AOF阻塞</p>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AOF%E9%98%BB%E5%A1%9E%E5%AE%9A%E4%BD%8D-redis%E6%97%A5%E5%BF%97.png" alt="AOF阻塞定位-redis日志.png"></p>
</li>
<li><p>命令：<code>info persistence</code></p>
<p><code>aof_delayed_fsync：100</code> ：表示累计阻塞的次数</p>
</li>
<li><p><code>top命令看硬盘情况</code></p>
</li>
</ol>
<h3 id="Redis复制的原理与优化"><a href="#Redis复制的原理与优化" class="headerlink" title="Redis复制的原理与优化"></a><strong>Redis复制的原理与优化</strong></h3><h4 id="主从复制两种实现方式"><a href="#主从复制两种实现方式" class="headerlink" title="主从复制两种实现方式"></a><strong>主从复制两种实现方式</strong></h4><h5 id="命令实现："><a href="#命令实现：" class="headerlink" title="命令实现："></a>命令实现：</h5><h6 id="开启-slaveof-ip-port"><a href="#开启-slaveof-ip-port" class="headerlink" title="开启 slaveof ip port"></a><strong>开启 <code>slaveof ip port</code></strong></h6><p>​                <strong>执行开启命令后，会把当前redis服务中的数据清楚，然后去复制主节点中的数据</strong></p>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%91%BD%E4%BB%A4-%E5%BC%80%E5%90%AF.png" alt="主从复制-命令-开启.png"></p>
<h6 id="取消主从复制-slaveof-no-one"><a href="#取消主从复制-slaveof-no-one" class="headerlink" title="取消主从复制 slaveof no one"></a><strong>取消主从复制 <code>slaveof no one</code></strong></h6><p>执行命令后，<strong>6380端口不会把之前同步6379服务的数据清除</strong>，<strong>只是不会在同步6379后面写入的数据</strong>。</p>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%91%BD%E4%BB%A4-%E5%8F%96%E6%B6%88.png" alt="主从复制-命令-取消.png"></p>
<h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a><strong>修改配置</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof ip port</span><br><span class="line">slave-read-only yes #从节点只是读，不进行写的操作</span><br></pre></td></tr></table></figure>

<h5 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a><strong>两种方式比较</strong></h5><table>
<thead>
<tr>
<th align="center"><strong>方式</strong></th>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>配置</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">不需要重启</td>
<td align="center">统一配置</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">不便于管理</td>
<td align="center">需要重启</td>
</tr>
</tbody></table>
<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a><strong>全量复制</strong></h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h5><p>用于初次复制或其它无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作，当数据量较大时，会对主从节点和网络造成很大的开销</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="全量复制.png"></p>
<h5 id="开销"><a href="#开销" class="headerlink" title="开销"></a><strong>开销</strong></h5><ol>
<li>bgsave时间</li>
<li>RDB文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB的时间</li>
<li>可能的AOF重写时间</li>
</ol>
<h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a><strong>部分复制</strong></h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h5><p>用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销，需要注意的是，如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制</p>
<h5 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a><strong>流程</strong></h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6.png" alt="部分复制.png"></p>
<h4 id="开发运维中的问题"><a href="#开发运维中的问题" class="headerlink" title="开发运维中的问题"></a><strong>开发运维中的问题</strong></h4><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h5><h6 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h6><p>读流量分摊到从节点</p>
<h6 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h6><ol>
<li>复制数据延迟</li>
<li>读到过期的数据(redis3.2解决了该问题)</li>
<li>从节点故障</li>
</ol>
<h5 id="配置不一致-利用标准化工具安装可避免"><a href="#配置不一致-利用标准化工具安装可避免" class="headerlink" title="配置不一致(利用标准化工具安装可避免)"></a>配置不一致(利用标准化工具安装可避免)</h5><ol>
<li>例如<code>maxmemory</code>不一致，导致数据丢失</li>
<li>例如数据结构优化参数(例如hash-max-ziplist-entries)：内存不一致</li>
</ol>
<h5 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h5><h6 id="第一次全量复制："><a href="#第一次全量复制：" class="headerlink" title="第一次全量复制："></a>第一次全量复制：</h6><ul>
<li>第一次不可避免</li>
<li>在低峰的时候进行</li>
</ul>
<h6 id="节点运行ID不匹配"><a href="#节点运行ID不匹配" class="headerlink" title="节点运行ID不匹配"></a>节点运行ID不匹配</h6><ul>
<li>主节点重启(运行ID变化)</li>
<li>故障转移，例如哨兵、集群</li>
</ul>
<h6 id="复制积压缓冲区不足"><a href="#复制积压缓冲区不足" class="headerlink" title="复制积压缓冲区不足"></a>复制积压缓冲区不足</h6><ul>
<li>网络中断，部分复制无法满足</li>
<li>增大复制缓冲区配置<code>rel_backlog_size</code>，网络增强</li>
</ul>
<h5 id="复制风暴"><a href="#复制风暴" class="headerlink" title="复制风暴"></a>复制风暴</h5><h6 id="单主节点复制风暴"><a href="#单主节点复制风暴" class="headerlink" title="单主节点复制风暴"></a>单主节点复制风暴</h6><ul>
<li><p><strong>问题</strong>：主节点重启，多从节点复制</p>
</li>
<li><p><strong>解决</strong>：更换复制拓扑（读写分离有问题）</p>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6%E9%A3%8E%E6%9A%B4.png" alt="单节点复制风暴.png"></p>
</li>
</ul>
<h6 id="单机器复制风暴（）"><a href="#单机器复制风暴（）" class="headerlink" title="单机器复制风暴（）"></a>单机器复制风暴（）</h6><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E6%9C%BA%E5%99%A8%E5%A4%8D%E5%88%B6%E9%A3%8E%E6%9A%B4.png" alt="单机器复制风暴.png"></p>
<h4 id="全量复制和部分复制相关问题"><a href="#全量复制和部分复制相关问题" class="headerlink" title="全量复制和部分复制相关问题"></a><strong>全量复制和部分复制相关问题</strong></h4><h5 id="redis什么时候会发生全量复制？"><a href="#redis什么时候会发生全量复制？" class="headerlink" title="redis什么时候会发生全量复制？"></a><strong>redis什么时候会发生全量复制？</strong></h5><ol>
<li>redis slave首启动或者重启后，连接到master时</li>
<li>redis slave进程没重启，但是掉线了，重连后不满足部分复制条件</li>
</ol>
<h5 id="redis什么时候会发生部分复制？"><a href="#redis什么时候会发生部分复制？" class="headerlink" title="redis什么时候会发生部分复制？"></a>redis什么时候会发生部分复制？</h5><p>先来看部分复制需要的条件</p>
<ol>
<li>主从的redis版本&gt;=2.8</li>
<li>redis slave进程没有重启，但是掉线了，重连了master(因为slave进程重启的话，run id就没有了)</li>
<li>redis slave保存的run id与master当前run id一致 (注：run id并不是pid，slave把它保存在内存中，重启就消失)</li>
<li>redis slave掉线期间，master保存在内存的offset可用，也就是master变化不大，被更改的指令都保存在内存</li>
</ol>
<h5 id="redis进程重启后会发生全量复制还是部分复制？"><a href="#redis进程重启后会发生全量复制还是部分复制？" class="headerlink" title="redis进程重启后会发生全量复制还是部分复制？"></a>redis进程重启后会发生全量复制还是部分复制？</h5><ol>
<li>master重启时，run id会发生变化</li>
<li>slave重启时，run id会丢失</li>
</ol>
<p><strong>答：很显然，会发生全量复制，因为部分复制的条件之一run id已经不能满足</strong></p>
<h5 id="当全量复制或者同步复制完毕，增量是如何更新到slave的？"><a href="#当全量复制或者同步复制完毕，增量是如何更新到slave的？" class="headerlink" title="当全量复制或者同步复制完毕，增量是如何更新到slave的？"></a>当全量复制或者同步复制完毕，增量是如何更新到slave的？</h5><p><strong>答：通过流式的命令更新，此时master就是slave的client，这样去理解。</strong></p>
<h5 id="run-id如何查看？"><a href="#run-id如何查看？" class="headerlink" title="run id如何查看？"></a>run id如何查看？</h5><p><strong>答：通过info server命令查看</strong></p>
<h3 id="Redis-Sentinel（哨兵）"><a href="#Redis-Sentinel（哨兵）" class="headerlink" title="Redis Sentinel（哨兵）"></a>Redis Sentinel（哨兵）</h3><h4 id="主从复制高可用问题"><a href="#主从复制高可用问题" class="headerlink" title="主从复制高可用问题"></a>主从复制高可用问题</h4><h5 id="手动故障转移-master出问题时要手动去处理"><a href="#手动故障转移-master出问题时要手动去处理" class="headerlink" title="手动故障转移(master出问题时要手动去处理)"></a>手动故障转移(master出问题时要手动去处理)</h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="主从复制-手动处理流程.png"></p>
<h5 id="写能力和存储能力受限"><a href="#写能力和存储能力受限" class="headerlink" title="写能力和存储能力受限"></a>写能力和存储能力受限</h5><h4 id="Redis-Sentinel故障转移流程"><a href="#Redis-Sentinel故障转移流程" class="headerlink" title="Redis Sentinel故障转移流程"></a>Redis Sentinel故障转移流程</h4><ol>
<li>多个sentinel发现并确认master有问题</li>
<li>选举出一个sentinel作为领导</li>
<li>选出一个slave作为master</li>
<li>通知其余slave成为新的master的slave</li>
<li>通知客户端主从变化</li>
<li>等待老的master复活成为新的master的slave</li>
</ol>
<h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><ol>
<li>配置开启主从节点</li>
<li>配置开启sentinel监控主节点(<strong>sentinel是特殊的redis，支持命令有限，本身不存储数据</strong>)</li>
<li>详细配置节点</li>
</ol>
<h4 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h4><h5 id="每10秒每个sentinel对master和slave节点执行info操作"><a href="#每10秒每个sentinel对master和slave节点执行info操作" class="headerlink" title="每10秒每个sentinel对master和slave节点执行info操作"></a>每10秒每个sentinel对master和slave节点执行<code>info</code>操作</h5><ol>
<li>发现slave节点</li>
<li>确认主从关系</li>
</ol>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis-Sentinel-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="Redis-Sentinel-第一个定时任务.png"></p>
<h5 id="每2秒每个sentinel通过master节点的channel交换信息-pub-sub"><a href="#每2秒每个sentinel通过master节点的channel交换信息-pub-sub" class="headerlink" title="每2秒每个sentinel通过master节点的channel交换信息(pub/sub)"></a>每2秒每个sentinel通过master节点的channel交换信息(pub/sub)</h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis-Sentinel-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="Redis-Sentinel-第二个定时任务.png"></p>
<ol>
<li>通过<code>__sentinel__</code>：hello交互频道信息</li>
<li>交互对节点的”看法”和自身的信息</li>
</ol>
<h5 id="（重要的一个）每1秒每个Sentinel对其他的Sentinel和Redis执行Ping（心跳检测，失败判断依据）"><a href="#（重要的一个）每1秒每个Sentinel对其他的Sentinel和Redis执行Ping（心跳检测，失败判断依据）" class="headerlink" title="（重要的一个）每1秒每个Sentinel对其他的Sentinel和Redis执行Ping（心跳检测，失败判断依据）"></a>（重要的一个）每1秒每个Sentinel对其他的Sentinel和Redis执行Ping（心跳检测，失败判断依据）</h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis-Sentinel-%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="Redis-Sentinel-第三个定时任务.png"></p>
<h4 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h4><h5 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h5><p>某个<code>sentinel</code>节点认为<code>Redis</code>节点不可用，’偏见’</p>
<h5 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h5><p>当Sentinel将一个<code>Redis</code>判断为主观下线之后，为了确定这个<code>Redis</code>是否真的下线了，它会向同样监视这个<code>Redis</code>的其它Sentinel进行询问，看它们是否也认为Master已经进入下线状态。当所有的<code>sentinel</code>节点对<code>Redis</code>节点失败”达成共识”(超过quorum个统一)，则该<code>Redis</code>节点客观下线</p>
<h4 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>只有一个sentinel几点完成故障转移</p>
<h5 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h5><h6 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h6><p>通过<code>sentinel is-master-down-by-addr</code>命令都希望成为领导者</p>
<h6 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h6><ol>
<li>每个做主观下线的Sentinel节点向其他Sentinel节点发送命令，要求将它设置为领导者</li>
<li>收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令，那么将同意该请求，否则拒绝</li>
<li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过<code>quorum</code>，那么它将成为领导者</li>
<li>如果此过程有多个Sentinel节点成为了领导者 ，那么将等待一段时间重新进行选举。</li>
</ol>
<h4 id="Redis-Sentinel总结"><a href="#Redis-Sentinel总结" class="headerlink" title="Redis Sentinel总结"></a>Redis Sentinel总结</h4><ol>
<li>Redis Sentinel是Redis高可用的实现方案（故障发现、故障自动转移、配置中心、客户端通知）</li>
<li>尽可能的在不同的机器上部署Redis Sentinel节点</li>
<li>Redis Sentinel中Sentinel节点个数应该大于等于3，最好为奇数</li>
<li>Redis Sentinel中的数据节点与普通数据节点没有区别</li>
<li>客户端初始化链接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心不是代理</li>
<li>Redis Sentinel是通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控</li>
<li>Redis Sentinel在对节点做失败判定时分为主观下线和客观下线</li>
<li>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化</li>
</ol>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><h4 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h4><ol>
<li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li>
<li>良好的哈希函数：例如 CRC16</li>
<li>服务端管理节点、槽、数据：例如Redis Cluster</li>
</ol>
<h4 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h4><h5 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/moved%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="moved重定向.png"></p>
<h6 id="槽命中：直接返回"><a href="#槽命中：直接返回" class="headerlink" title="槽命中：直接返回"></a>槽命中：直接返回</h6><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/moved-%E6%A7%BD%E5%91%BD%E4%B8%AD.png" alt="moved-槽命中.png"></p>
<h6 id="槽不命中：moved异常"><a href="#槽不命中：moved异常" class="headerlink" title="槽不命中：moved异常"></a>槽不命中：moved异常</h6><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/moved-%E6%A7%BD%E4%B8%8D%E5%91%BD%E4%B8%AD%E5%BC%82%E5%B8%B8.png" alt="moved-槽不命中异常.png"></p>
<h5 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h5><p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ASK-%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="ASK-重定向.png"></p>
<h5 id="moved和ASK"><a href="#moved和ASK" class="headerlink" title="moved和ASK"></a>moved和ASK</h5><ul>
<li>两者都是客户单重定向</li>
<li>moved：槽已经确定迁移</li>
<li>ASK：槽还在迁移中</li>
</ul>
<h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li><p>从集群中选一个可运行节点，使用 cluster slots初始化槽和节点映射</p>
</li>
<li><p>将cluser slots的结果映射到本地，为每个节点创建JedisPool</p>
</li>
<li><p>准备执行命令</p>
<p><img src="/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis-cluster-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Redis-cluster-客户端执行流程.png"></p>
</li>
</ol>
<h4 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h4><ul>
<li>通过ping/pong消息实现故障发现，<strong>不需要sentinel</strong></li>
<li>主观下线和客观下线</li>
</ul>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><h5 id="资格检查"><a href="#资格检查" class="headerlink" title="资格检查"></a>资格检查</h5><ul>
<li>每个从节点检查与故障主节点的断线时间</li>
<li>超过<code>cluster-node-tit * cluster-slave-validity-facor</code>取消资格</li>
<li><code>cluster-slave-validity-factor</code>：默认为10</li>
</ul>
<h5 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h5><h5 id="选举投票"><a href="#选举投票" class="headerlink" title="选举投票"></a>选举投票</h5><h5 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h5><ul>
<li>当前从节点取消复制变为主节点。（<code>slaveof no one</code>）</li>
<li>执行<code>clusterDelSlot</code>撤销故障主节点负责的槽，并执行<code>clusterAddSlot</code>把这些槽分配给自己</li>
<li>向集群广播自己的ponmg消息，表明已经替换了故障主节点</li>
</ul>
<h4 id="Redis-Cluster开发运维常见问题"><a href="#Redis-Cluster开发运维常见问题" class="headerlink" title="Redis Cluster开发运维常见问题"></a>Redis Cluster开发运维常见问题</h4><h5 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h5><ul>
<li><code>cluster-require-full-coverage</code>默认为yes：表示集群所有节点正常才提供服务</li>
<li>多数业务无法容忍，建议<code>cluster-require-full-coverage</code>设置为<strong>no</strong></li>
</ul>
<h5 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h5><ul>
<li><p>Ping/Pong消息</p>
</li>
<li><p>官方建议节点不要超过1000个</p>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><ul>
<li>避免多个业务使用一个大集群</li>
<li><code>cluster-node-timeout</code>：带宽和故障转移速度的均衡</li>
<li>尽量均匀分配到多机器上：保证高可用和带宽</li>
</ul>
</li>
</ul>
<h5 id="Pub-Sub广播"><a href="#Pub-Sub广播" class="headerlink" title="Pub/Sub广播"></a>Pub/Sub广播</h5><h6 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h6><p>publish在集群每个节点广播：加重带宽</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>单独”走”一套Redis Sentinel</p>
<h5 id="集群倾斜"><a href="#集群倾斜" class="headerlink" title="集群倾斜"></a>集群倾斜</h5><h6 id="数据倾斜：内存不均匀"><a href="#数据倾斜：内存不均匀" class="headerlink" title="数据倾斜：内存不均匀"></a>数据倾斜：内存不均匀</h6><ul>
<li>节点和槽分配不均匀</li>
<li>不同槽对应键值数量差异较大</li>
<li>包含bigkey(可在从节点执行<code>redis-cli --bigkeys</code>查找)</li>
<li>内存相关配置不一致</li>
</ul>
<h6 id="请求倾斜"><a href="#请求倾斜" class="headerlink" title="请求倾斜"></a>请求倾斜</h6><ul>
<li>热点key或者bigkey</li>
</ul>
<h5 id="集群读写分离"><a href="#集群读写分离" class="headerlink" title="集群读写分离"></a>集群读写分离</h5><h6 id="只读链接"><a href="#只读链接" class="headerlink" title="只读链接"></a>只读链接</h6><p>集群模式的从节点不接受任何读写请求</p>
<ul>
<li>读取数据时会重定向负责槽的主节点</li>
<li><code>readonly</code>命令可以在从节点上读，但是这是链接级别的命令</li>
</ul>
<h6 id="读写分离（较复杂，cluster模式下不建议使用）"><a href="#读写分离（较复杂，cluster模式下不建议使用）" class="headerlink" title="读写分离（较复杂，cluster模式下不建议使用）"></a>读写分离（较复杂，cluster模式下不建议使用）</h6><h5 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h5><h6 id="官方迁移工具-redis-tribrb-import"><a href="#官方迁移工具-redis-tribrb-import" class="headerlink" title="官方迁移工具(redis-tribrb import)"></a>官方迁移工具(redis-tribrb import)</h6><ul>
<li>只能从单机迁移到集群</li>
<li>不支持在线迁移：source需要停写</li>
<li>不支持断点续传</li>
<li>单线程迁移：影响速度</li>
</ul>
<center><h3>欢迎扫码关注</h3></center>

<blockquote>
<p> 如果喜欢请关注我公众号【程序倾听者】，说出你的故事！我在这里倾听！</p>
<p> <img src="/images/public-wechat.jpg" alt></p>
</blockquote>

      
      <!-- reward -->
      
      <div id="reward-btn">
        顶我一下下!
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong>
              本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/05/26/redis/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%90%8E%E7%AB%AF/" rel="tag">Java后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/05/28/%E6%8C%91%E6%88%98Spring%E7%B3%BB%E5%88%97/Spring%20IOC%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            【挑战 Spring】—– Spring IOC 源码调试三之loadBeanDefinitions
          
        </div>
      </a>
    
    
      <a href="/2020/05/21/%E6%8C%91%E6%88%98Spring%E7%B3%BB%E5%88%97/Spring%20IOC%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%BA%8C/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">【挑战 Spring】—– Spring IOC 源码调试二</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'monsterid',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> ListenerSun
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="倾听者"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/life/">生活随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我吃个棒棒糖可否~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>